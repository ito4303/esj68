---
title: R, BUGS, Stanによる階層モデルのあてはめ
author: "伊東宏樹（森林総合研究所北海道支所）"
date: "2021-03-17"
output:
  beamer_presentation:
    latex_engine: lualatex
    theme: metropolis
    keep_tex: false
    includes:
      in_header: header.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(comment = NA)
knitr::opts_chunk$set(prompt = TRUE)
library(stringr)
library(AHMbook)
library(unmarked)
library(rjags)
library(cmdstanr)
options(mc.cores = parallel::detectCores())
```

## 本日の発表内容

- **サイト占有モデル**
    - 模擬データの作成
    - unmarked, BUGS (JAGS), Stanによる当てはめ
- ***N*** **混合モデル**
    - 模擬データの作成
    - unmarked, BUGS (JAGS), Stanによる当てはめ

## 本日のコード

本日のコードは以下の場所に置いてあります。

https://github.com/ito4303/esj68

時間の都合で，詳細な説明はできませんので，興味のある方は
自分で動かしてみてください。

# サイト占有モデル

## サイト占有モデルの構造

\includegraphics[width=11cm]{Site_occ.pdf}

## サイト占有モデルの構造

\begin{align*}
z &\sim \mathrm{Bern}(\psi) \\
y_j &\sim \mathrm{Bern}(z p_j)
\end{align*}

- $z$: 在・不在
- $\psi$: 占有確率
- $y_j$: $j$回目の観測での検出・不検出
- $p_j$: $j$回目の観測での検出確率

## 模擬データの生成

```{r set_seed, include=FALSE}
set.seed(123)
```


```{r gen_site_occ_data, echo=2, results='hide'}
pdf(file = "occ_data%0d.pdf", width = 9, height = 6, onefile = FALSE)
occ_data <- AHMbook::simOcc(
  M = 300,                # Number of sites
  J = 2,                  # Number of temporal replicates
  mean.occupancy = 0.6,   # Mean occupancy prob.
  beta1 = -2,             # Main effect of elev. on occ.
  beta2 = 2,              # Main effect of forest on occ.
  beta3 = 0,              # Interaction of elev. and forest
  mean.detection = 0.3,   # Mean detection prob.
  time.effects = c(0, 0), # Time effect on det.
  alpha1 = 0,             # Main effect of elev. on det.
  alpha2 = -3,            # Main effect of wind speed on det.
  alpha3 = 0,             # Interaction of elev and wind
  sd.lp = 0.5,            # S.D. of random site effects
  b = 0)                  # Behavioral response
dev.off()
```

## データの確認

真の占有サイト数

```{r view_site_occ_data1, echo=TRUE}
sum(occ_data$z)
```

観測された占有サイト数

```{r view_site_occ_data2, echo=TRUE}
sum(apply(occ_data$y, 1, max))
```

## データの確認

最初の6サイトの真値と観測値

```{r view_site_occ_data3, echo=TRUE}
head(cbind(z = occ_data$z, occ_data$y))
```

---

\includegraphics[width=11cm]{occ_data1.pdf}

---

\includegraphics[width=11cm]{occ_data2.pdf}

# unmarkedによる占有モデルの当てはめ

## unmarkedオブジェクトの作成

```{r occ_unmarked, echo=TRUE}
umf <- unmarkedFrameOccu(
  y = occ_data$y,
  siteCovs = data.frame(elev = occ_data$elev,
                        forest = occ_data$forest),
  obsCovs = list(wind = occ_data$wind))
```

## unmarkedオブジェクト

```{r occ_unmarked_summary, echo=TRUE, eval=FALSE}
summary(umf)
```

```{r}
out <- capture.output(summary(umf))
cat(out[1:11], sep = "\n")
```

---

```{r}
cat(out[12:20], sep = "\n")
```

---

```{r}
cat(out[21:28], sep = "\n")
```

## あてはめ（切片だけのモデル）

```{r occ_unmarked_fit, echo=TRUE}
(fm0 <- occu(~ 1  ~ 1, data = umf))
```

<!--
```{r, echo=TRUE}
#backTransform(fm0, "state")
```
-->

<!--
```{r, echo=TRUE}
#backTransform(fm0, "det")
```
-->

## あてはめ（共変量のあるモデル）

```{r occ_unmarked_fit2, echo=TRUE}
(fm1 <- occu(~ wind ~ elev + forest, data = umf))
```

## モデル選択

```{r model_selection, echo=TRUE}
fms <- fitList('psi(.)p(.)' = fm0,
               'psi(Elev+Forest)p(Wind)' = fm1)
modSel(fms)
```

## 占有サイト数

経験ベイズによる占有サイト数推定値の事後平均

(真値は `r sum(occ_data$z)`)

<!-- bup: best unbiassed predictor -->

```{r occ_unmarked_num_occ_sites, echo=TRUE}
sum(bup(ranef(fm1), stat = "mean"))
```


# BUGSによる占有モデルの当てはめ

## BUGS言語で記述したモデル

```{r occ_bugs_model}
model_file <- "occ.txt"
s <- scan(model_file, what = character(), sep = "\n")
p <- str_which(s, "# priors")
cat(s[1:(p - 1)], sep = "\n")
```

---

```{r}
cat(s[p:length(s)], sep = "\n")
```

## JAGSによる推定結果

```{r occ_jags, include=FALSE}
set.seed(1)
jags_data <- list(M = occ_data$M, J = occ_data$J, y = occ_data$y,
                  elev = occ_data$elev, forest = occ_data$forest,
                  wind = occ_data$wind)
ini_fun <- function() {
  list(beta = rnorm(3, 0, 2),
       alpha = rnorm(2, 0, 2),
       z = rep(1, occ_data$M))
}
rdata_file <- "occ_jags.RData"
if (file.exists(rdata_file) &
    (file.mtime(rdata_file) > file.mtime(model_file))) {
  load(rdata_file)
} else {
  mod_occ_jags <- jags.model(model_file, data = jags_data,
                             inits = ini_fun, n.chains = 3)
  update(mod_occ_jags, 1000)
  fit_occ_jags <- coda.samples(mod_occ_jags, n.iter = 1000,
                               variable.names = c("beta", "alpha",
                                                  "Nocc", "z"))
  save(fit_occ_jags, file = rdata_file)
}
```

```{r occ_jags_summary, echo=TRUE}
print(summary(fit_occ_jags)$statistics[1:6, ], digits = 2)
```


# Stanによる占有モデルのあてはめ

## zを消去

あるサイトで観測値$\{y_1,\dots,y_{J}\}$が得られる確率

\begin{align*}
\Pr(\{y_1,\dots,y_{J}\} &\mid \psi, \{p_1,\dots,p_{J}\}) = \\
&\begin{cases}
\mathrm{Bern}(1 \mid \psi) \prod_{j=1}^{J}\mathrm{Bern}(y_{j} \mid p_{j}) & (\exists y_{j} = 1) \\
\mathrm{Bern}(0 \mid \psi) + \mathrm{Bern}(1 \mid \psi) \prod_{j=1}^{J}\mathrm{Bern}(0 \mid p_{j}) & (\forall y_{j} = 0)
\end{cases}
\end{align*}

## Stanのモデル

<!--
`data`ブロックと`transformed data`ブロック

```{r occ_stan_model}
model_file <- "occ.stan"
s <- scan(model_file, what = character(), sep = "\n")
p1 <- str_which(s, "^parameters")
cat(s[1:(p1 - 1)], sep = "\n")
```

---

`parameters`ブロックと`transformed parameters`ブロック

```{r}
p2 <- str_which(s, "^model")
cat(s[p1:(p2 - 1)], sep = "\n")
```

---
-->

`model`ブロック

```{r}
p3 <- str_which(s, "^generated quantities")
cat(s[p2:(p3 - 1)], sep = "\n")
```

---

`generated quantities`ブロック

```{r}
cat(s[p3:length(s)], sep = "\n")
```

## 結果

```{r occ_stan, include=FALSE}
output_file <- "occ_stan.RDS"
if (file.exists(output_file) &
    file.mtime(output_file) > file.mtime(model_file)) {
  fit_occ_stan <- readRDS(output_file)
} else {
  stan_data <- list(M = occ_data$M, J = occ_data$J, Y = occ_data$y,
                    Elev = occ_data$elev, Forest = occ_data$forest,
                    Wind = occ_data$wind)
  mod_occ_stan <- cmdstan_model(model_file)
  fit_occ_stan <- mod_occ_stan$sample(data = stan_data, seed = 1,
                                      chains = 4, parallel_chains = 4,
                                      iter_sampling = 1000,
                                      iter_warmup = 1000,
                                    refresh = 500)
  fit_occ_stan$save_object(output_file)
}
```

```{r occ_stan_summary, echo=TRUE}
fit_occ_stan$print(c("beta", "alpha", "Nocc"))
```


# *N*混合モデル

## *N*混合モデルの構造

\includegraphics[width=11cm]{N-mixture.pdf}

## *N*混合モデルの構造

\begin{align*}
n &\sim \mathrm{Pois}(\lambda) \\
y_j &\sim \mathrm{Binom}(n, p_j)
\end{align*}

- $n$: 真の個体数量
- $\lambda$: 期待個体数量
- $y_j$: $j$回目の観測での観測個体数量
- $p_j$: $j$回目の観測での観測確率

## 模擬データ

```{r, include=FALSE}
set.seed(1234)
```

```{r nmix_data, echo=2, results='hide'}
pdf(file = "nmix_data%0d.pdf", width = 8, height = 6, onefile = FALSE)
nmix_data <- AHMbook::simNmix(
  nsites = 120,         # Number of sites
  nvisits = 2,          # Number of visits per site
  mean.lam = 2,         # Expected abundance
  mean.p = 0.6,         # Expected detection
  beta2.lam = 0.5,      # Coef. of site covariate 2
                        # in abundance model
  beta.p.survey = 0.8)  # Coef. of survey covariate on p
dev.off()
```

## データの確認

最初の6サイトの真値と観測値

```{r}
head(cbind(N = nmix_data$N, nmix_data$C))
```

総個体数

```{r}
sum(nmix_data$N)
```

---

\includegraphics[width=11cm]{nmix_data9.pdf}


# unmarkedによる*N*混合モデルの当てはめ

## unmarkedオブジェクトの作成

```{r nmix_unmarked, echo=TRUE}
umf <- unmarkedFramePCount(
  y = nmix_data$C,
  siteCovs = data.frame(site_cov =
                          nmix_data$site.cov[, 2]),
  obsCovs = list(survey_cov = nmix_data$survey.cov))
```

## unmarkedオブジェクト

```{r nmix_unmarked_summary, echo=TRUE, eval=FALSE}
summary(umf)
```

```{r}
out <- capture.output(summary(umf))
cat(out[1:11], sep = '\n')
```

---

```{r}
cat(out[12:20], sep = '\n')
```

---

```{r}
cat(out[21:28], sep = '\n')
```

## あてはめ

```{r nmix_unmarked_fit, echo=TRUE}
fm2 <- pcount( ~ survey_cov ~ site_cov, data = umf, K = 110)
print(fm2)
```

## 総個体数

経験ベイズによる総個体数推定値の事後平均

(真値は `r sum(nmix_data$N)`)

```{r nmix_unmarked_N, echo=TRUE}
sum(bup(ranef(fm2), stat = "mean"))
```


# BUGSによる*N*混合モデルの当てはめ

## BUGS言語で記述したモデル

```{r nmix_bugs_model}
model_file <- "nmix.txt"
s <- scan(model_file, what = character(), sep = "\n")
p <- str_which(s, "# priors")
cat(s[1:(p - 1)], sep = "\n")
```

---

```{r}
cat(s[p:length(s)], sep = "\n")
```


## JAGSによる推定結果

```{r nmix_jags, include=FALSE}
set.seed(1)
jags_data <- list(M = nmix_data$nsites, J = nmix_data$nvisits,
                  y = nmix_data$C,
                  cov.abn = nmix_data$site.cov[, 2],
                  cov.det = nmix_data$survey.cov)
ini_fun <- function() {
  list(beta = rnorm(2, 0, 2),
       alpha = rnorm(2, 0, 2),
       n = apply(nmix_data$C, 1, max))
}
rdata_file <- "nmix_jags.RData"
if (file.exists(rdata_file) &
    (file.mtime(rdata_file) > file.mtime(model_file))) {
  load(rdata_file)
} else {
  mod_nmix_jags <- jags.model(model_file, data = jags_data,
                              inits = ini_fun, n.chains = 3)
  update(mod_nmix_jags, 1000)
  fit_nmix_jags <- coda.samples(mod_nmix_jags, n.iter = 2000,
                                variable.names = c("beta", "alpha",
                                                   "Ntotal", "n"))
  save(fit_nmix_jags, file = rdata_file)
}
```

```{r nmix_jags_summary, echo=TRUE}
print(summary(fit_nmix_jags)$statistics[1:5, ], digits = 2)
```


# Stanによる*N*混合モデルの当てはめ

## nを消去

あるサイトで観測値$\{y_1,\dots,y_{J}\}$が得られる確率

\begin{align*}
\Pr(\{y_{1},\dots,y_{J}\} &\mid \lambda, \{p_{1},\dots,p_{J}\}) = \\
& \sum_{n=\mathrm{max}(\boldsymbol{y})}^{\infty}\mathrm{Pois}(n \mid \lambda)\prod_{j=1}^{J}\mathrm{Binom}(y_{j} \mid n, p_{j})
\end{align*}

## Stanのモデル

<!--
`data`ブロックと`parameters`ブロック

```{r nmix_stan_model}
model_file <- "nmix.stan"
s <- scan(model_file, what = character(), sep = "\n")
p1 <- str_which(s, "^transformed parameters")
cat(s[1:(p1 - 1)], sep = "\n")
```

---
-->

`transformed parameters`ブロック

```{r}
p2 <- str_which(s, "^model")
cat(s[p1:(p2 - 1)], sep = "\n")
```

---

`model`ブロック

```{r}
p3 <- str_which(s, "^generated quantities")
cat(s[p2:(p3 - 1)], sep = "\n")
```

---

`generated quantities`ブロック

```{r}
cat(s[p3:length(s)], sep = "\n")
```

## 結果

```{r nmix_stan_1, include=FALSE}
output_file <- "nmix_stan1.RDS"
stan_data <- list(M = nmix_data$nsites, J = nmix_data$nvisits,
                  Y = nmix_data$C,
                  Cov_abn = nmix_data$site.cov[, 2],
                  Cov_det = nmix_data$survey.cov,
                  Max_N = max(nmix_data$C) + 100)
if (file.exists(output_file) &
    file.mtime(output_file) > file.mtime(model_file)) {
  fit_nmix_stan_1 <- readRDS(output_file)
} else {
  mod_nmix_stan_1 <- cmdstan_model(model_file)
  fit_nmix_stan_1 <- mod_nmix_stan_1$sample(
    data = stan_data, seed = 1,
    chains = 4, parallel_chains = 4,
    iter_sampling = 1000,
    iter_warmup = 1000,
    refresh = 500)
  fit_nmix_stan_1$save_object(output_file)
}
```

```{r nmix1_stan_summary, echo=TRUE}
fit_nmix_stan_1$print(c("beta", "alpha", "Ntotal"))
```

## 2変量ポアソン分布を使用したモデル化

- $N$混合モデルは多変量ポアソン(multivariate Poisson)分布に等価(Dennis et al. 2015)
    - 2回測定の$N$混合モデルは，2変量ポアソン分布でモデル化できる。

---

2変量ポアソン分布の確率質量関数を定義

```{r nmix_stan_model3}
model_file <- "nmix_bp.stan"
s <- scan(model_file, what = character(), sep = "\n")
p1 <- str_which(s, "^  real bivariate_poisson")
p2 <- str_which(s, "^  int n_mixture_rng")
cat(s[c(1, p1:(p2 - 1))], sep = "\n")
```

---

`model`ブロック

```{r}
p3 <- str_which(s, "^model")
p4 <- str_which(s, "^generated quantities")
cat(s[p3:(p4 - 1)], sep = "\n")
```

## 結果

```{r nmix_stan_3, include=FALSE}
output_file <- "nmix_stan3.RDS"
if (file.exists(output_file) &
    file.mtime(output_file) > file.mtime(model_file)) {
  fit_nmix_stan_3 <- readRDS(output_file)
} else {
  mod_nmix_stan_3 <- cmdstan_model(model_file)
  fit_nmix_stan_3 <- mod_nmix_stan_3$sample(
    data = stan_data, seed = 1,
    chains = 4, parallel_chains = 4,
    iter_sampling = 1000,
    iter_warmup = 1000,
    refresh = 500)
  fit_nmix_stan_3$save_object(output_file)
}
```


```{r nmix_stan_3_summary, echo=TRUE}
fit_nmix_stan_3$print(c("beta", "alpha", "Ntotal"))
```

## まとめ

- unmarked, JAGS, Stan のそれぞれで，サイト占有モデルや$N$混合モデルのあてはめができる。
- モデル構造が比較的単純なら，unmarkedが簡単。
- モデルが複雑になると，BUGSやStanによるモデルの記述が必要になるかもしれない。
- Stanでは，離散パラメータを扱えないが，周辺化消去したり，アルゴリズムを工夫することで，サイト占有モデルや，$N$混合モデルを扱える。
    - ただし，モデルの記述が直感的ではなくなる場合もある。


